// Generated by CoffeeScript 1.4.0
(function() {
  var changingSession, isPlainObject, onpopstate, orderedStringify, sessions, sha256_base64, writePending, writeSession;

  if (Meteor.isServer) {
    sessions = {};
    Meteor.methods({
      rememberSession: function(hash, serialized) {
        console.log('rememberSession', hash, serialized);
        return sessions[hash] = serialized;
      },
      fetchSession: function(hash) {
        var session;
        session = sessions[hash];
        console.log('fetchSession', hash, '->', session);
        return session;
      }
    });
  }

  if (!Meteor.isClient) {
    return;
  }

  isPlainObject = function(x) {
    return _.isObject(x) && !(_.isString(x) || _.isNumber(x) || _.isBoolean(x) || _.isDate(x) || _.isArray(x));
  };

  orderedStringify = function(x) {
    var r;
    if (isPlainObject(x)) {
      r = '{';
      _.each(_.keys(x).sort(), function(key, index) {
        if (index !== 0) {
          r += ',';
        }
        return r += JSON.stringify(key) + ':' + orderedStringify(x[key]);
      });
      return r + '}';
    } else {
      return EJSON.stringify(x);
    }
  };

  sha256_base64 = function(input) {
    var binaryHash, hexHash, i, _i, _ref;
    hexHash = Meteor._srp.SHA256(input);
    binaryHash = '';
    for (i = _i = 0, _ref = hexHash.length; _i < _ref; i = _i += 2) {
      binaryHash += String.fromCharCode(parseInt(hexHash.substr(i, 2), 16));
    }
    return btoa(binaryHash).replace(/\=+$/, '');
  };

  writePending = false;

  changingSession = false;

  writeSession = function() {
    var hash, serialized;
    serialized = orderedStringify(Session.keys);
    hash = sha256_base64(serialized);
    Meteor.call('rememberSession', hash, serialized);
    writePending = false;
    return history.pushState(null, '', '/' + hash);
  };

  Meteor.__sessionSetHook = function() {
    if (!(writePending || changingSession)) {
      writePending = true;
      return setTimeout(writeSession, 0);
    }
  };

  onpopstate = function() {
    var hash;
    hash = window.location.pathname.substr(1);
    return Meteor.call('fetchSession', hash, function(err, serialized) {
      var unserialized;
      if (err || !(serialized != null)) {
        return;
      }
      unserialized = EJSON.parse(serialized);
      changingSession = true;
      _.each(unserialized, function(value, key) {
        value = EJSON.parse(value);
        return Session.set(key, value);
      });
      return changingSession = false;
    });
  };

  window.addEventListener('popstate', onpopstate, false);

  Meteor.startup(function() {
    return onpopstate();
  });

}).call(this);
